<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on terryzh&#39;s blog</title>
    <link>https://t496971418.github.io/categories/golang/</link>
    <description>Recent content in Golang on terryzh&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Jan 2019 11:44:32 +0800</lastBuildDate>
    
	<atom:link href="https://t496971418.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang如何管理项目依赖</title>
      <link>https://t496971418.github.io/posts/golang%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Wed, 09 Jan 2019 11:44:32 +0800</pubDate>
      
      <guid>https://t496971418.github.io/posts/golang%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/</guid>
      <description>在学习golang的过程中发现，golang一般不会作为新手的第一门语言进行学习，简而言之，golang虽然设计巧妙，但是蕴含了很多的编程技巧在里面，对新手可以说是很不友好。
做过web开发的不管是前端还是后端都会有这样一个疑问，如何对自己的项目依赖包进行管理。前端有npm，后端有gradle。
今天要介绍的就是golang在应对爆发式的第三方开源包时，做出的历史演进。
如果是单纯的写技术文应该是蛮无聊的，所以我会把故事（历史发展）和技术（干货）分开为两个大段来讲。既可以温故知新，又可以让能看到我文章的人觉得，哎，这篇文章还蛮有意思的。
golang在对包管理的历史演进 介绍GOPATH和GOROOT
很多人，包括博主在内，刚开始学习golang的时候都是对这两个东西一头雾水，不知道在说什么，因为博主是前端出生，以个人的理解可以把GOPATH看成是package.json安装的全局第三方包。
GOROOT
golang的默认安装路径，会指定版本GOROOT=&amp;quot;/usr/local/Cellar/go/1.11.2/libexec&amp;quot;
GOPATH
 src存放源代码(比如：.go .c .h .s等) 按照golang默认约定，go run，go install等命令的当前工作路径（即在此路径下执行上述命令）。 pkg编译时生成的中间文件（比如：.a）　golang编译包时 bin编译后生成的可执行文件（为了方便，可以把此目录加入到 $PATH 变量中，如果有多个gopath，那么使用${GOPATH//://bin:}/bin添加所有的bin目录  没有包管理的情况下
在golang项目搭建初期，所引用的第三方包是比较少的，可以直接使用go get 拉取第三方包，但是相应的就是没有依赖文件，第三方包的引用只能在对应的import文件中去寻找，这极大的延长了敏捷开发的时间和成本。
vendor go作为一个现代化的语言，居然要用这么复杂不直观而又不标准的方法来管理依赖，难怪在早期会有很多人非常不看好go的前景。
为了解决这个问题，go在1.5版本引入了vendor属性(默认关闭，需要设置go环境变量GO15VENDOREXPERIMENT=1)，并在1.6版本中默认开启了vendor属性。
vendor属性就是让go编译时，优先从项目源码树根目录下的vendor目录查找代码(可以理解为切了一次GOPATH)，如果vendor中有，则不再去GOPATH中去查找
 vendor依旧存在的问题。1. vendor目录中依赖包没有版本信息。这样依赖包脱离了版本管理，对于升级、问题追溯，会有点困难。 2. 如何方便的得到本项目依赖了哪些包，并方便的将其拷贝到vendor目录下？ Manual is fxxk.
 在此基础上的进一步演进
 godep govendor glide dep  细数相关用法 godep docker，kubernetes， coreos等go项目很多都是使用godep来管理其依赖，当然原因可能是早期也没的工具可选。
godep早期版本并不依赖vendor，所以对go的版本要求很松，go 1.5之前的版本也可以用，只是行为上有所不同。在vendor推出以后，godep也改为使用vendor了。
godep使用很简单：当你的项目编写好了，使用GOPATH的依赖包测试ok了的时候，执行：
$ godep save
以hcache为例，执行go save，会做2件事：
 扫描本项目的代码，将hcache项目依赖的包及该包的版本号(即git commit)记录到Godeps/Godeps.json文件中 将依赖的代码从GOPATH/src中copy到vendor目录(忽略原始代码的.git目录)。对于不支持vendor的早期版本，则会拷贝到Godeps/_workspace/里  一个Godeps.json的例子
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  { &amp;#34;ImportPath&amp;#34;: &amp;#34;github.</description>
    </item>
    
  </channel>
</rss>