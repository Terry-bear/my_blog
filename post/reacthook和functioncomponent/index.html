<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>ReactHook和FunctionComponent - Terryzh</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Terryzh" /><meta name="description" content="React 生命周期很多人都了解，但通常我们所了解的都是 单个组件 的生命周期，但针对 Hooks 组件、多个关联组件（父子组件和兄弟组件） 的生命周期又是怎么样的喃？" /><meta name="keywords" content="javascript" />






<meta name="generator" content="Hugo 0.54.0 with even 4.0.0" />


<link rel="canonical" href="http://www.elixir-zh.cn/post/reacthook%E5%92%8Cfunctioncomponent/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.65dce888.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="ReactHook和FunctionComponent" />
<meta property="og:description" content="React 生命周期很多人都了解，但通常我们所了解的都是 单个组件 的生命周期，但针对 Hooks 组件、多个关联组件（父子组件和兄弟组件） 的生命周期又是怎么样的喃？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.elixir-zh.cn/post/reacthook%E5%92%8Cfunctioncomponent/" />
<meta property="article:published_time" content="2019-07-30T16:45:27&#43;08:00"/>
<meta property="article:modified_time" content="2019-07-30T16:45:27&#43;08:00"/>

<meta itemprop="name" content="ReactHook和FunctionComponent">
<meta itemprop="description" content="React 生命周期很多人都了解，但通常我们所了解的都是 单个组件 的生命周期，但针对 Hooks 组件、多个关联组件（父子组件和兄弟组件） 的生命周期又是怎么样的喃？">


<meta itemprop="datePublished" content="2019-07-30T16:45:27&#43;08:00" />
<meta itemprop="dateModified" content="2019-07-30T16:45:27&#43;08:00" />
<meta itemprop="wordCount" content="3909">



<meta itemprop="keywords" content="javascript," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ReactHook和FunctionComponent"/>
<meta name="twitter:description" content="React 生命周期很多人都了解，但通常我们所了解的都是 单个组件 的生命周期，但针对 Hooks 组件、多个关联组件（父子组件和兄弟组件） 的生命周期又是怎么样的喃？"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Terryzh</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Terryzh</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">ReactHook和FunctionComponent</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-07-30 </span>
        <div class="post-category">
            <a href="/categories/code/"> code </a>
            </div>
          <span class="more-meta"> 3909 words </span>
          <span class="more-meta"> 8 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#一-hooks-组件">一、Hooks 组件</a></li>
<li><a href="#二-单个组件的生命周期">二、单个组件的生命周期</a>
<ul>
<li><a href="#1-生命周期">1. 生命周期</a>
<ul>
<li><a href="#v16-3-之前">V16.3 之前</a></li>
<li><a href="#v16-3-之后">V16.3 之后</a></li>
</ul></li>
<li><a href="#2-生命周期-误区">2. 生命周期，误区</a></li>
</ul></li>
<li><a href="#三-多个组件的执行顺序">三、多个组件的执行顺序</a>
<ul>
<li><a href="#1-父子组件">1. 父子组件</a></li>
<li><a href="#2-兄弟组件">2. 兄弟组件</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>React 生命周期很多人都了解，但通常我们所了解的都是 <strong>单个组件</strong> 的生命周期，但针对 <strong>Hooks 组件、多个关联组件</strong>（父子组件和兄弟组件） 的生命周期又是怎么样的喃？你有思考和了解过吗，接下来我们将完整的了解 React 生命周期。</p>

<p>关于 <strong>组件</strong> ，我们这里指的是 <code>React.Component</code> 以及 <code>React.PureComponent</code> ，但是否包括 Hooks 组件喃？</p>

<h3 id="一-hooks-组件">一、Hooks 组件</h3>

<p><strong>函数组件</strong> 的本质是函数，没有 state 的概念的，因此<strong>不存在生命周期</strong>一说，仅仅是一个 <strong>render 函数</strong>而已。</p>

<p>但是引入 <strong>Hooks</strong> 之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念，所谓的生命周期其实就是 <code>useState</code>、 <code>useEffect()</code> 和 <code>useLayoutEffect()</code> 。</p>

<p>即：<strong>Hooks 组件（使用了Hooks的函数组件）有生命周期，而函数组件（未使用Hooks的函数组件）是没有生命周期的</strong>。</p>

<p>下面，是具体的 class 与 Hooks 的<strong>生命周期对应关系</strong>：</p>

<ul>
<li><code>constructor</code>：函数组件不需要构造函数，我们可以通过调用 <strong>useState 来初始化 state</strong>。如果计算的代价比较昂贵，也可以传一个函数给 <code>useState</code>。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx">  <span class="k">const</span> <span class="p">[</span><span class="nx">num</span><span class="p">,</span> <span class="nx">UpdateNum</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li><code>getDerivedStateFromProps</code>：一般情况下，我们不需要使用它，我们可以在<strong>渲染过程中更新 state</strong>，以达到实现 <code>getDerivedStateFromProps</code> 的目的。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx">  <span class="kd">function</span> <span class="nx">ScrollView</span><span class="p">({</span><span class="nx">row</span><span class="p">})</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="p">[</span><span class="nx">isScrollingDown</span><span class="p">,</span> <span class="nx">setIsScrollingDown</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="kd">let</span> <span class="p">[</span><span class="nx">prevRow</span><span class="p">,</span> <span class="nx">setPrevRow</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="nx">row</span> <span class="o">!==</span> <span class="nx">prevRow</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Row 自上次渲染以来发生过改变。更新 isScrollingDown。
</span><span class="c1"></span>    <span class="nx">setIsScrollingDown</span><span class="p">(</span><span class="nx">prevRow</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">row</span> <span class="o">&gt;</span> <span class="nx">prevRow</span><span class="p">);</span>
    <span class="nx">setPrevRow</span><span class="p">(</span><span class="nx">row</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="sb">`Scrolling down: </span><span class="si">${</span><span class="nx">isScrollingDown</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>
  <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>React 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。</p>

<ul>
<li><code>shouldComponentUpdate</code>：可以用 <strong>React.memo</strong> 包裹一个组件来对它的 <code>props</code> 进行浅比较</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx">  <span class="k">const</span> <span class="nx">Button</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">((</span><span class="nx">props</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 具体的组件
</span><span class="c1"></span>  <span class="p">});</span></code></pre></td></tr></table>
</div>
</div>
<p>注意：<strong>React.memo 等效于 PureComponent</strong>，它只浅比较 props。这里也可以使用 <code>useMemo</code> 优化每一个节点。</p>

<ul>
<li><p><code>render</code>：这是函数组件体本身。</p></li>

<li><p><code>componentDidMount</code>, <code>componentDidUpdate</code>：<code>useLayoutEffect</code> 与它们两的调用阶段是一样的。但是，我们推荐你<strong>一开始先用 useEffect</strong>，只有当它出问题的时候再尝试使用 <code>useLayoutEffect</code>。<code>useEffect</code> 可以表达所有这些的组合。</p></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx">  <span class="c1">// componentDidMount
</span><span class="c1"></span>  <span class="nx">useEffect</span><span class="p">(()=&gt;{</span>
  <span class="c1">// 需要在 componentDidMount 执行的内容
</span><span class="c1"></span>  <span class="p">},</span> <span class="p">[])</span>
  
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容
</span><span class="c1"></span>  <span class="nb">document</span><span class="p">.</span><span class="nx">title</span> <span class="o">=</span> <span class="sb">`You clicked </span><span class="si">${</span><span class="nx">count</span><span class="si">}</span><span class="sb"> times`</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="c1">// 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）
</span><span class="c1"></span>    <span class="c1">// 以及 componentWillUnmount 执行的内容
</span><span class="c1"></span>  <span class="p">}</span> <span class="c1">// 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关
</span><span class="c1"></span>  <span class="p">},</span> <span class="p">[</span><span class="nx">count</span><span class="p">]);</span> <span class="err">// 仅在 count 更改时更新</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 useEffect，因此会使得额外操作很方便</strong></p>

<ul>
<li><code>componentWillUnmount</code>：相当于 <code>useEffect</code> 里面返回的 <code>cleanup</code> 函数</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx">  <span class="c1">// componentDidMount/componentWillUnmount
</span><span class="c1"></span>  <span class="nx">useEffect</span><span class="p">(()=&gt;{</span>
  <span class="c1">// 需要在 componentDidMount 执行的内容
</span><span class="c1"></span>  <span class="k">return</span> <span class="kd">function</span> <span class="nx">cleanup</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 需要在 componentWillUnmount 执行的内容
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="p">},</span> <span class="p">[])</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li><code>componentDidCatch</code> and <code>getDerivedStateFromError</code>：目前<strong>还没有</strong>这些方法的 Hook 等价写法，但很快会加上。</li>
</ul>

<p>为方便记忆，大致汇总成表格如下。</p>

<table>
<thead>
<tr>
<th align="left">class 组件</th>
<th align="left">Hooks 组件</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">constructor</td>
<td align="left">useState</td>
</tr>

<tr>
<td align="left">getDerivedStateFromProps</td>
<td align="left">useState 里面 update 函数</td>
</tr>

<tr>
<td align="left">shouldComponentUpdate</td>
<td align="left">useMemo</td>
</tr>

<tr>
<td align="left">render</td>
<td align="left">函数本身</td>
</tr>

<tr>
<td align="left">componentDidMount</td>
<td align="left">useEffect</td>
</tr>

<tr>
<td align="left">componentDidUpdate</td>
<td align="left">useEffect</td>
</tr>

<tr>
<td align="left">componentWillUnmount</td>
<td align="left">useEffect  里面返回的函数</td>
</tr>

<tr>
<td align="left">componentDidCatch</td>
<td align="left">无</td>
</tr>

<tr>
<td align="left">getDerivedStateFromError</td>
<td align="left">无</td>
</tr>
</tbody>
</table>

<h3 id="二-单个组件的生命周期">二、单个组件的生命周期</h3>

<h4 id="1-生命周期">1. 生命周期</h4>

<h5 id="v16-3-之前">V16.3 之前</h5>

<p>我们可以将生命周期分为三个阶段：</p>

<ul>
<li>挂载阶段</li>
<li>组件更新阶段</li>
<li>卸载阶段</li>
</ul>

<p>分开来讲：</p>

<ol>
<li>挂载阶段</li>
</ol>

<ul>
<li><code>constructor</code>：避免将 props 的值复制给 state</li>
<li><code>componentWillMount</code></li>
<li><code>render</code>：react 最重要的步骤，创建虚拟 dom，进行 diff 算法，更新 dom 树都在此进行</li>
<li><code>componentDidMount</code></li>
</ul>

<ol>
<li>组件更新阶段</li>
</ol>

<ul>
<li><code>componentWillReceiveProps</code></li>
<li><code>shouldComponentUpdate</code></li>
<li><code>componentWillUpdate</code></li>
<li><code>render</code></li>
<li><code>componentDidUpdate</code></li>
</ul>

<ol>
<li>卸载阶段</li>
</ol>

<ul>
<li><code>componentWillUnMount</code></li>
</ul>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQTPNhqTrahyVXbsBA8rDnibliceXf1QdJ9Gwy12sFia1ELHzPg3oyh3HO8iavlTyHaYp4gfju6rBfGTHg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" /></p>

<p>这种生命周期会存在一个问题，那就是当更新复杂组件的最上层组件时，调用栈会很长，如果在进行复杂的操作时，就可能长时间阻塞主线程，带来不好的用户体验，<strong>Fiber</strong> 就是为了解决该问题而生。</p>

<h5 id="v16-3-之后">V16.3 之后</h5>

<p><strong>Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。</strong></p>

<p>对于异步渲染，分为两阶段：</p>

<ul>
<li><code>reconciliation</code>：</li>
<li><code>componentWillMount</code></li>
<li><code>componentWillReceiveProps</code></li>
<li><code>shouldConmponentUpdate</code></li>
<li><code>componentWillUpdate</code></li>
<li><code>commit</code></li>
<li><code>componentDidMount</code></li>
<li><code>componentDidUpdate</code></li>
</ul>

<p>其中，<code>reconciliation</code> 阶段是可以被打断的，所以 <code>reconcilation</code> 阶段执行的函数就会出现多次调用的情况，显然，这是不合理的。</p>

<p>所以 V16.3 引入了新的 API 来解决这个问题：</p>

<ol>
<li><code>static getDerivedStateFromProps</code>：该函数在<strong>挂载阶段和组件更新阶段</strong>都会执行，即<strong>每次获取新的props 或 state 之后都会被执行</strong>，<strong>在挂载阶段用来代替componentWillMount</strong>；在组件更新阶段配合 <code>componentDidUpdate</code>，可以覆盖 <code>componentWillReceiveProps</code> 的所有用法。</li>
</ol>

<p>同时它是一个静态函数，所以函数体内不能访问 <code>this</code>，会根据 <code>nextProps</code> 和 <code>prevState</code> 计算出预期的状态改变，返回结果会被送给 <code>setState</code><strong>，</strong>返回 <code>null</code> 则说明不需要更新 <code>state</code>，并且这个返回是<strong>必须的</strong>。</p>

<ol>
<li><code>getSnapshotBeforeUpdate</code>: 该函数会在 <strong>render 之后， DOM 更新前</strong>被调用，用于读取最新的 DOM 数据。</li>
</ol>

<p>返回一个值，<strong>作为 componentDidUpdate 的第三个参数</strong>；配合 <code>componentDidUpdate</code>, 可以覆盖<code>componentWillUpdate</code> 的所有用法。</p>

<p>注意：V16.3 中只用在组件挂载或组件 <code>props</code> 更新过程才会调用，即如果是因为自身 setState 引发或者forceUpdate 引发，而不是由父组件引发的话，那么<code>static getDerivedStateFromProps</code>也不会被调用，在 V16.4 中更正为都调用。</p>

<p>即更新后的生命周期为：</p>

<ol>
<li>挂载阶段</li>
</ol>

<ul>
<li><code>constructor</code></li>
<li><code>static getDerivedStateFromProps</code></li>
<li><code>render</code></li>
<li><code>componentDidMount</code></li>
</ul>

<ol>
<li>更新阶段</li>
</ol>

<ul>
<li><code>static getDerivedStateFromProps</code></li>
<li><code>shouldComponentUpdate</code></li>
<li><code>render</code></li>
<li><code>getSnapshotBeforeUpdate</code></li>
<li><code>componentDidUpdate</code></li>
</ul>

<ol>
<li>卸载阶段</li>
</ol>

<ul>
<li><code>componentWillUnmount</code></li>
</ul>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQTPNhqTrahyVXbsBA8rDniblBKLPgjoD9AhiarDDaUQqwxrW770ISkE1pmibwJpO6tdSAMMD29icBQW4w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" /></p>

<h4 id="2-生命周期-误区">2. 生命周期，误区</h4>

<p><strong>误解一：</strong><code>getDerivedStateFromProps</code> 和 <code>componentWillReceiveProps</code> 只会在 <code>props</code> <strong>改变</strong> 时才会调用</p>

<p>实际上，<strong>只要父级重新渲染，getDerivedStateFromProps 和 componentWillReceiveProps 都会重新调用，不管 props 有没有变化</strong>。所以，在这两个方法内直接将 props 赋值到 state 是不安全的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="c1">// 子组件
</span><span class="c1"></span><span class="k">class</span> <span class="nx">PhoneInput</span> <span class="k">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">phone</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">phone</span> <span class="p">};</span>

  <span class="nx">handleChange</span> <span class="o">=</span> <span class="nx">e</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">phone</span><span class="o">:</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span> <span class="p">});</span>
  <span class="p">};</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="p">{</span> <span class="nx">phone</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">input</span> <span class="na">onChange</span><span class="o">=</span><span class="s">{this.handleChange}</span> <span class="na">value</span><span class="o">=</span><span class="s">{phone}</span> <span class="p">/&gt;;</span>
  <span class="p">}</span>

  <span class="nx">componentWillReceiveProps</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 不要这样做。
</span><span class="c1"></span>    <span class="c1">// 这会覆盖掉之前所有的组件内 state 更新！
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">phone</span><span class="o">:</span> <span class="nx">nextProps</span><span class="p">.</span><span class="nx">phone</span> <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 父组件
</span><span class="c1"></span><span class="k">class</span> <span class="nx">App</span> <span class="k">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">count</span><span class="o">:</span> <span class="mi">0</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="nx">componentDidMount</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 使用了 setInterval，
</span><span class="c1"></span>    <span class="c1">// 每秒钟都会更新一下 state.count
</span><span class="c1"></span>    <span class="c1">// 这将导致 App 每秒钟重新渲染一次
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">interval</span> <span class="o">=</span> <span class="nx">setInterval</span><span class="p">(</span>
      <span class="p">()</span> <span class="p">=&gt;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">prevState</span> <span class="p">=&gt;</span> <span class="p">({</span>
          <span class="nx">count</span><span class="o">:</span> <span class="nx">prevState</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">})),</span>
      <span class="mi">1000</span>
    <span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">componentWillUnmount</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">clearInterval</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">interval</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;&gt;</span>
        <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>
          <span class="nx">Start</span> <span class="nx">editing</span> <span class="nx">to</span> <span class="nx">see</span> <span class="nx">some</span> <span class="nx">magic</span> <span class="nx">happen</span> <span class="o">:</span><span class="p">)</span>
        <span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">PhoneInput</span> <span class="na">phone</span><span class="o">=</span><span class="s">&#39;call me!&#39;</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>
          <span class="nx">This</span> <span class="nx">component</span> <span class="nx">will</span> <span class="nx">re</span><span class="o">-</span><span class="nx">render</span> <span class="nx">every</span> <span class="nx">second</span><span class="p">.</span> <span class="nx">Each</span> <span class="nx">time</span> <span class="nx">it</span> <span class="nx">renders</span><span class="p">,</span> <span class="nx">the</span>
          <span class="nx">text</span> <span class="nx">you</span> <span class="nx">type</span> <span class="nx">will</span> <span class="nx">be</span> <span class="nx">reset</span><span class="p">.</span> <span class="nx">This</span> <span class="nx">illustrates</span> <span class="nx">a</span> <span class="nx">derived</span> <span class="nx">state</span>
          <span class="nx">anti</span><span class="o">-</span><span class="nx">pattern</span><span class="p">.</span>
        <span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
      <span class="o">&lt;</span><span class="err">/&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>实例可点击这里查看</p>

<p>当然，我们可以在 父组件App 中 <code>shouldComponentUpdate</code> 比较 props 的 email 是不是修改再决定要不要重新渲染，但是如果子组件接受多个 props（较为复杂），就很难处理，而且 <code>shouldComponentUpdate</code> 主要是用来性能提升的，不推荐开发者操作 <code>shouldComponetUpdate</code>（可以使用 <code>React.PureComponet</code>）。</p>

<p>我们也可以使用 <strong>在 props 变化后修改 state</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="k">class</span> <span class="nx">PhoneInput</span> <span class="k">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">phone</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">phone</span>
  <span class="p">};</span>

  <span class="nx">componentWillReceiveProps</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 只要 props.phone 改变，就改变 state
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">nextProps</span><span class="p">.</span><span class="nx">phone</span> <span class="o">!==</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">phone</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
        <span class="nx">phone</span><span class="o">:</span> <span class="nx">nextProps</span><span class="p">.</span><span class="nx">phone</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>但这种也会导致一个问题，当 props 较为复杂时，props 与 state 的关系不好控制，可能导致问题</p>

<p>解决方案一：<strong>完全可控的组件</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="kd">function</span> <span class="nx">PhoneInput</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">&lt;</span><span class="nt">input</span> <span class="na">onChange</span><span class="o">=</span><span class="s">{props.onChange}</span> <span class="na">value</span><span class="o">=</span><span class="s">{props.phone}</span> <span class="p">/&gt;;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>完全由 <strong>props</strong> 控制，不派生 <strong>state</strong></p>

<p>解决方案二：<strong>有 key 的非可控组件</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="k">class</span> <span class="nx">PhoneInput</span> <span class="k">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">phone</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">defaultPhone</span> <span class="p">};</span>

  <span class="nx">handleChange</span> <span class="o">=</span> <span class="nx">event</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="nx">phone</span><span class="o">:</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span> <span class="p">});</span>
  <span class="p">};</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">input</span> <span class="na">onChange</span><span class="o">=</span><span class="s">{this.handleChange}</span> <span class="na">value</span><span class="o">=</span><span class="s">{this.state.phone}</span> <span class="p">/&gt;;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">&lt;</span><span class="nt">PhoneInput</span>
  <span class="na">defaultPhone</span><span class="o">=</span><span class="s">{this.props.user.phone}</span>
  <span class="na">key</span><span class="o">=</span><span class="s">{this.props.user.id}</span>
<span class="p">/&gt;</span></code></pre></td></tr></table>
</div>
</div>
<p>当 <code>key</code> 变化时， React 会<strong>创建一个新的而不是更新一个既有的组件</strong></p>

<p><strong>误解二</strong>：将 props 的值直接复制给 state</p>

<p>应避免将 <strong>props</strong> 的值复制给 <strong>state</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-jsx" data-lang="jsx"><span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
 <span class="c1">// 千万不要这样做
</span><span class="c1"></span> <span class="c1">// 直接用 props，保证单一数据源
</span><span class="c1"></span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">phone</span><span class="o">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">phone</span> <span class="p">};</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="三-多个组件的执行顺序">三、多个组件的执行顺序</h3>

<h4 id="1-父子组件">1. 父子组件</h4>

<ul>
<li><strong>挂载阶段</strong></li>
</ul>

<p>分 <strong>两个</strong> 阶段：</p>

<ul>
<li><p>第 <strong>一</strong> 阶段，由父组件开始执行到自身的 <code>render</code>，解析其下有哪些子组件需要渲染，并对其中 <strong>同步的子组件</strong> 进行创建，按 <strong>递归顺序</strong> 挨个执行各个子组件至 <code>render</code>，生成到父子组件对应的 Virtual DOM 树，并 commit 到 DOM。</p></li>

<li><p>第 <strong>二</strong> 阶段，此时 DOM 节点已经生成完毕，组件挂载完成，开始后续流程。先依次触发同步子组件各自的 <code>componentDidMount</code>，最后触发父组件的。</p></li>
</ul>

<p><strong>注意</strong>：如果父组件中包含异步子组件，则会在父组件挂载完成后被创建。</p>

<p>所以执行顺序是：</p>

<p>父组件 getDerivedStateFromProps —&gt; 同步子组件 getDerivedStateFromProps —&gt; 同步子组件 componentDidMount —&gt; 父组件 componentDidMount —&gt; 异步子组件 getDerivedStateFromProps —&gt; 异步子组件 componentDidMount</p>

<ul>
<li><strong>更新阶段</strong></li>
</ul>

<p><strong>React 的设计遵循单向数据流模型</strong> ，也就是说，数据均是由父组件流向子组件。</p>

<ul>
<li>第 <strong>一</strong> 阶段，由父组件开始，执行</li>
</ul>

<p>更新到自身的 <code>render</code>，解析其下有哪些子组件需要渲染，并对 <strong>子组件</strong> 进行创建，按 <strong>递归顺序</strong> 挨个执行各个子组件至 <code>render</code>，生成到父子组件对应的 Virtual DOM 树，并与已有的 Virtual DOM 树 比较，计算出 <strong>Virtual DOM 真正变化的部分</strong> ，并只针对该部分进行的原生DOM操作。</p>

<ul>
<li><ol>
<li><code>static getDerivedStateFromProps</code></li>
</ol>

<ol>
<li><code>shouldComponentUpdate</code></li>
</ol></li>

<li><p>第 <strong>二</strong> 阶段，此时 DOM 节点已经生成完毕，组件挂载完成，开始后续流程。先依次触发同步子组件以下函数，最后触发父组件的。</p></li>
</ul>

<p>React 会按照上面的顺序依次执行这些函数，每个函数都是各个子组件的先执行，然后才是父组件的执行。</p>

<p>所以执行顺序是：</p>

<p>父组件 getDerivedStateFromProps —&gt; 父组件 shouldComponentUpdate —&gt; 子组件 getDerivedStateFromProps —&gt; 子组件 shouldComponentUpdate —&gt; 子组件 getSnapshotBeforeUpdate —&gt;  父组件 getSnapshotBeforeUpdate —&gt; 子组件 componentDidUpdate —&gt; 父组件 componentDidUpdate</p>

<ul>
<li><ol>
<li><code>getSnapshotBeforeUpdate()</code></li>
</ol>

<ol>
<li><code>componentDidUpdate()</code></li>
</ol></li>

<li><p><strong>卸载阶段</strong></p></li>
</ul>

<p><code>componentWillUnmount()</code>，顺序为 <strong>父组件的先执行，子组件按照在 JSX 中定义的顺序依次执行各自的方法</strong>。</p>

<p><strong>注意</strong> ：如果卸载旧组件的同时伴随有新组件的创建，新组件会先被创建并执行完 <code>render</code>，然后卸载不需要的旧组件，最后新组件执行挂载完成的回调。</p>

<h4 id="2-兄弟组件">2. 兄弟组件</h4>

<ul>
<li><strong>挂载阶段</strong></li>
</ul>

<p>若是同步路由，它们的创建顺序和其在共同父组件中定义的先后顺序是 <strong>一致</strong> 的。</p>

<p>若是异步路由，它们的创建顺序和 js 加载完成的顺序一致。</p>

<ul>
<li><strong>更新阶段、卸载阶段</strong></li>
</ul>

<p>兄弟节点之间的通信主要是经过父组件（Redux 和 Context 也是通过改变父组件传递下来的 <code>props</code> 实现的），<strong>满足React 的设计遵循单向数据流模型</strong>， <strong>因此任何两个组件之间的通信，本质上都可以归结为父子组件更新的情况</strong> 。</p>

<p>所以，兄弟组件更新、卸载阶段，请参考 <strong>父子组件</strong>。</p>
    </div>

    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/reward/wechat-qr-code.png">
        <span>wechat</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/reward/alipay-qr-code.png">
        <span>alipay</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/javascript/">javascript</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E8%BD%ACjs%E4%B8%AD%E5%85%AB%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">[转]JS中八种继承方案分析</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/%E8%AF%91%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8react-hooks%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/">
            <span class="next-text nav-default">[译]如何使用React Hooks获取数据</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '2019-07-30 16:45:27 \x2b0800 \x2b0800',
        title: 'ReactHook和FunctionComponent',
        clientID: 'bf0ed9ea18e819e40135',
        clientSecret: '92bdc65717aa7f0ec48bfe94e773b57a21163785',
        repo: 'blog_comments',
        owner: '496971418@qq.com',
        admin: ['496971418@qq.com'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:terryzh017@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://stackoverflow.com/users/10838177/terryzh" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://twitter.com/terryzhAizz" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/t496971418" class="iconfont icon-github" title="github"></a>
  <a href="http://www.elixir-zh.cn/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Terryzh</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
