<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>深入理解TypeScript 1 - Terryzh&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Terryzh" /><meta name="description" content="这一章主要总结TypeScript的用法和项目常用配置 编译上下文 用来给文件分组，告诉 TypeScript 哪些文件是有效的，哪些是无效的。定义这种逻辑分组，一个" /><meta name="keywords" content="javascript, typescript" />






<meta name="generator" content="Hugo 0.53 with even 4.0.0" />


<link rel="canonical" href="http://www.aizz.top/post/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript-1/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="深入理解TypeScript 1" />
<meta property="og:description" content="这一章主要总结TypeScript的用法和项目常用配置 编译上下文 用来给文件分组，告诉 TypeScript 哪些文件是有效的，哪些是无效的。定义这种逻辑分组，一个" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.aizz.top/post/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3typescript-1/" /><meta property="article:published_time" content="2019-01-22T11:25:36&#43;08:00"/>
<meta property="article:modified_time" content="2019-01-22T11:25:36&#43;08:00"/>

<meta itemprop="name" content="深入理解TypeScript 1">
<meta itemprop="description" content="这一章主要总结TypeScript的用法和项目常用配置 编译上下文 用来给文件分组，告诉 TypeScript 哪些文件是有效的，哪些是无效的。定义这种逻辑分组，一个">


<meta itemprop="datePublished" content="2019-01-22T11:25:36&#43;08:00" />
<meta itemprop="dateModified" content="2019-01-22T11:25:36&#43;08:00" />
<meta itemprop="wordCount" content="4861">



<meta itemprop="keywords" content="javascript,typescript," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="深入理解TypeScript 1"/>
<meta name="twitter:description" content="这一章主要总结TypeScript的用法和项目常用配置 编译上下文 用来给文件分组，告诉 TypeScript 哪些文件是有效的，哪些是无效的。定义这种逻辑分组，一个"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Terryzh&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Terryzh&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">深入理解TypeScript 1</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-01-22 </span>
        <div class="post-category">
            <a href="/categories/code/"> code </a>
            </div>
          <span class="more-meta"> 4861 words </span>
          <span class="more-meta"> 10 mins read </span>
        
      </div>
    </header>

    
    <div class="post-content">
      <p>这一章主要总结TypeScript的用法和项目常用配置</p>

<h2 id="编译上下文">编译上下文</h2>

<p>用来给文件分组，告诉 TypeScript 哪些文件是有效的，哪些是无效的。定义这种逻辑分组，一个比较好的方式是使用 <code>tsconfig.json</code> 文件。</p>

<p><strong>常用配置一览</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json">    <span class="p">{</span>
      <span class="nt">&#34;compilerOptions&#34;</span><span class="p">:</span> <span class="p">{</span>

        <span class="err">/*</span> <span class="err">基本选项</span> <span class="err">*/</span>
        <span class="nt">&#34;target&#34;</span><span class="p">:</span> <span class="s2">&#34;es5&#34;</span><span class="p">,</span>                       <span class="err">//</span> <span class="err">指定</span> <span class="err">ECMAScript</span> <span class="err">目标版本:</span> <span class="err">&#39;ES3&#39;</span> <span class="err">(default),</span> <span class="err">&#39;ES5&#39;,</span> <span class="err">&#39;ES2015&#39;,</span> <span class="err">&#39;ES2016&#39;,</span> <span class="err">&#39;ES2017&#39;,</span> <span class="err">or</span> <span class="err">&#39;ESNEXT&#39;</span>
        <span class="nt">&#34;module&#34;</span><span class="p">:</span> <span class="s2">&#34;commonjs&#34;</span><span class="p">,</span>                  <span class="err">//</span> <span class="err">指定使用模块:</span> <span class="err">&#39;commonjs&#39;,</span> <span class="err">&#39;amd&#39;,</span> <span class="err">&#39;system&#39;,</span> <span class="err">&#39;umd&#39;</span> <span class="err">or</span> <span class="err">&#39;es2015&#39;</span>
        <span class="nt">&#34;lib&#34;</span><span class="p">:</span> <span class="p">[],</span>                             <span class="err">//</span> <span class="err">指定要包含在编译中的库文件</span>
        <span class="nt">&#34;allowJs&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>                       <span class="err">//</span> <span class="err">允许编译</span> <span class="err">javascript</span> <span class="err">文件</span>
        <span class="nt">&#34;checkJs&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>                       <span class="err">//</span> <span class="err">报告</span> <span class="err">javascript</span> <span class="err">文件中的错误</span>
        <span class="nt">&#34;jsx&#34;</span><span class="p">:</span> <span class="s2">&#34;preserve&#34;</span><span class="p">,</span>                     <span class="err">//</span> <span class="err">指定</span> <span class="err">jsx</span> <span class="err">代码的生成:</span> <span class="err">&#39;preserve&#39;,</span> <span class="err">&#39;react-native&#39;,</span> <span class="err">or</span> <span class="err">&#39;react&#39;</span>
        <span class="nt">&#34;declaration&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>                   <span class="err">//</span> <span class="err">生成相应的</span> <span class="err">&#39;.d.ts&#39;</span> <span class="err">文件</span>
        <span class="nt">&#34;sourceMap&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>                     <span class="err">//</span> <span class="err">生成相应的</span> <span class="err">&#39;.map&#39;</span> <span class="err">文件</span>
        <span class="nt">&#34;outFile&#34;</span><span class="p">:</span> <span class="s2">&#34;./&#34;</span><span class="p">,</span>                       <span class="err">//</span> <span class="err">将输出文件合并为一个文件</span>
        <span class="nt">&#34;outDir&#34;</span><span class="p">:</span> <span class="s2">&#34;./&#34;</span><span class="p">,</span>                        <span class="err">//</span> <span class="err">指定输出目录</span>
        <span class="nt">&#34;rootDir&#34;</span><span class="p">:</span> <span class="s2">&#34;./&#34;</span><span class="p">,</span>                       <span class="err">//</span> <span class="err">用来控制输出目录结构</span> <span class="err">--outDir.</span>
        <span class="nt">&#34;removeComments&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>                <span class="err">//</span> <span class="err">删除编译后的所有的注释</span>
        <span class="nt">&#34;noEmit&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>                        <span class="err">//</span> <span class="err">不生成输出文件</span>
        <span class="nt">&#34;importHelpers&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>                 <span class="err">//</span> <span class="err">从</span> <span class="err">tslib</span> <span class="err">导入辅助工具函数</span>
        <span class="nt">&#34;isolatedModules&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>               <span class="err">//</span> <span class="err">将每个文件做为单独的模块</span> <span class="err">（与</span> <span class="err">&#39;ts.transpileModule&#39;</span> <span class="err">类似）.</span>

        <span class="err">/*</span> <span class="err">严格的类型检查选项</span> <span class="err">*/</span>
        <span class="nt">&#34;strict&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>                        <span class="err">//</span> <span class="err">启用所有严格类型检查选项</span>
        <span class="nt">&#34;noImplicitAny&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>                 <span class="err">//</span> <span class="err">在表达式和声明上有隐含的</span> <span class="err">any类型时报错</span>
        <span class="nt">&#34;strictNullChecks&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>              <span class="err">//</span> <span class="err">启用严格的</span> <span class="err">null</span> <span class="err">检查</span>
        <span class="nt">&#34;noImplicitThis&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>                <span class="err">//</span> <span class="err">当</span> <span class="err">this</span> <span class="err">表达式值为</span> <span class="err">any</span> <span class="err">类型的时候，生成一个错误</span>
        <span class="nt">&#34;alwaysStrict&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>                  <span class="err">//</span> <span class="err">以严格模式检查每个模块，并在每个文件里加入</span> <span class="err">&#39;use</span> <span class="err">strict&#39;</span>

        <span class="err">/*</span> <span class="err">额外的检查</span> <span class="err">*/</span>
        <span class="nt">&#34;noUnusedLocals&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>                <span class="err">//</span> <span class="err">有未使用的变量时，抛出错误</span>
        <span class="nt">&#34;noUnusedParameters&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>            <span class="err">//</span> <span class="err">有未使用的参数时，抛出错误</span>
        <span class="nt">&#34;noImplicitReturns&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>             <span class="err">//</span> <span class="err">并不是所有函数里的代码都有返回值时，抛出错误</span>
        <span class="nt">&#34;noFallthroughCasesInSwitch&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>    <span class="err">//</span> <span class="err">报告</span> <span class="err">switch</span> <span class="err">语句的</span> <span class="err">fallthrough</span> <span class="err">错误。（即，不允许</span> <span class="err">switch</span> <span class="err">的</span> <span class="err">case</span> <span class="err">语句贯穿）</span>

        <span class="err">/*</span> <span class="err">模块解析选项</span> <span class="err">*/</span>
        <span class="nt">&#34;moduleResolution&#34;</span><span class="p">:</span> <span class="s2">&#34;node&#34;</span><span class="p">,</span>            <span class="err">//</span> <span class="err">选择模块解析策略：</span> <span class="err">&#39;node&#39;</span> <span class="err">(Node.js)</span> <span class="err">or</span> <span class="err">&#39;classic&#39;</span> <span class="err">(TypeScript</span> <span class="err">pre-1.6)</span>
        <span class="nt">&#34;baseUrl&#34;</span><span class="p">:</span> <span class="s2">&#34;./&#34;</span><span class="p">,</span>                       <span class="err">//</span> <span class="err">用于解析非相对模块名称的基目录</span>
        <span class="nt">&#34;paths&#34;</span><span class="p">:</span> <span class="p">{},</span>                           <span class="err">//</span> <span class="err">模块名到基于</span> <span class="err">baseUrl</span> <span class="err">的路径映射的列表</span>
        <span class="nt">&#34;rootDirs&#34;</span><span class="p">:</span> <span class="p">[],</span>                        <span class="err">//</span> <span class="err">根文件夹列表，其组合内容表示项目运行时的结构内容</span>
        <span class="nt">&#34;typeRoots&#34;</span><span class="p">:</span> <span class="p">[],</span>                       <span class="err">//</span> <span class="err">包含类型声明的文件列表</span>
        <span class="nt">&#34;types&#34;</span><span class="p">:</span> <span class="p">[],</span>                           <span class="err">//</span> <span class="err">需要包含的类型声明文件名列表</span>
        <span class="nt">&#34;allowSyntheticDefaultImports&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>  <span class="err">//</span> <span class="err">允许从没有设置默认导出的模块中默认导入。</span>

        <span class="err">/*</span> <span class="err">Source</span> <span class="err">Map</span> <span class="err">Options</span> <span class="err">*/</span>
        <span class="nt">&#34;sourceRoot&#34;</span><span class="p">:</span> <span class="s2">&#34;./&#34;</span><span class="p">,</span>                    <span class="err">//</span> <span class="err">指定调试器应该找到</span> <span class="err">TypeScript</span> <span class="err">文件而不是源文件的位置</span>
        <span class="nt">&#34;mapRoot&#34;</span><span class="p">:</span> <span class="s2">&#34;./&#34;</span><span class="p">,</span>                       <span class="err">//</span> <span class="err">指定调试器应该找到映射文件而不是生成文件的位置</span>
        <span class="nt">&#34;inlineSourceMap&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>               <span class="err">//</span> <span class="err">生成单个</span> <span class="err">soucemaps</span> <span class="err">文件，而不是将</span> <span class="err">sourcemaps</span> <span class="err">生成不同的文件</span>
        <span class="nt">&#34;inlineSources&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>                 <span class="err">//</span> <span class="err">将代码与</span> <span class="err">sourcemaps</span> <span class="err">生成到一个文件中，要求同时设置了</span> <span class="err">--inlineSourceMap</span> <span class="err">或</span> <span class="err">--sourceMap</span> <span class="err">属性</span>

        <span class="err">/*</span> <span class="err">其他选项</span> <span class="err">*/</span>
        <span class="nt">&#34;experimentalDecorators&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>        <span class="err">//</span> <span class="err">启用装饰器</span>
        <span class="nt">&#34;emitDecoratorMetadata&#34;</span><span class="p">:</span> <span class="kc">true</span>          <span class="err">//</span> <span class="err">为装饰器提供元数据的支持</span>
      <span class="p">}</span>
    <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="typescript-编译"><strong>TypeScript 编译</strong></h2>

<p>好的 IDE 支持对 TypeScript 的即时编译。但是，如果你想在使用 <code>tsconfig.json</code> 时从命令行手动运行 TypeScript 编译器，你可以通过以下方式：</p>

<ul>
<li>运行 tsc，它会在当前目录或者是父级目录寻找 <code>tsconfig.json</code> 文件。</li>
<li>运行 <code>tsc -p ./path-to-project-directory</code> 。当然，这个路径可以是绝对路径，也可以是相对于当前目录的相对路径。</li>
</ul>

<p>你甚至可以使用 <code>tsc -w</code> 来启用 TypeScript 编译器的观测模式，在检测到文件改动之后，它将重新编译。</p>

<h1 id="声明空间">声明空间</h1>

<p>在 TypeScript 里存在两种声明空间：<strong>类型声明空间</strong>与<strong>变量声明空间</strong>。我将会在下文中和大家讨论这两个概念。</p>

<h2 id="类型声明空间"><strong>类型声明空间</strong></h2>

<p>类型声明空间包含用来当做类型注解的内容，例如以下的一些类型声明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{};</span>
    <span class="kr">interface</span> <span class="nx">Bar</span> <span class="p">{};</span>
    <span class="nx">type</span> <span class="nx">Bas</span> <span class="o">=</span> <span class="p">{};</span></code></pre></td></tr></table>
</div>
</div>
<p>你可以将 <code>Foo</code>, <code>Bar</code>, <code>Bas</code> 做为类型注解使用，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kd">let</span> <span class="nx">foo</span>: <span class="kt">Foo</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">bar</span>: <span class="kt">Bar</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">bas</span>: <span class="kt">Bas</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>注意，尽管你定义了 <code>interface Bar</code>，你并不能够将它做为一个变量使用，因为它没有定义在变量声明空间中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">interface</span> <span class="nx">Bar</span> <span class="p">{}</span>
    <span class="kr">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">Bar</span><span class="p">;</span> <span class="err">// Error: &#34;cannot find name &#39;Bar&#39;&#34;</span></code></pre></td></tr></table>
</div>
</div>
<p>提示 <code>cannot find name 'Bar'</code> 的原因是名称 <code>Bar</code> 并未定义在变量声明空间。这将带领我们进入下一个主题 &ldquo;变量声明空间&rdquo;。</p>

<h2 id="变量声明空间"><strong>变量声明空间</strong></h2>

<p>变量声明空间包含可用作变量的内容，在上文中 <code>Class Foo</code> 提供了一个类型 <code>Foo</code> 到类型声明空间，此外它同样提供了一个变量 <code>Foo</code> 到变量声明空间，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{}</span>
    <span class="kr">const</span> <span class="nx">someVar</span> <span class="o">=</span> <span class="nx">Foo</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">someOtherVar</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>这很棒，尤其是当你想把一个类来当做变量传递时。</p>

<blockquote>
<p><strong>WARNING</strong></p>

<p>我们并不能使用一些像 <code>interface</code> 定义的内容，来当做变量使用。</p>
</blockquote>

<p>与此相似，一些像你用 <code>var</code> 声明的变量，也仅能在变量声明空间使用，不能用作类型注解。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">bar</span>: <span class="kt">foo</span><span class="p">;</span> <span class="err">// ERROR: &#34;cannot find name &#39;foo&#39;&#34;</span></code></pre></td></tr></table>
</div>
</div>
<p>提示 <code>cannot find name</code> 的原因是，名称 <code>foo</code> 没有定义在类型声明空间里。</p>

<h1 id="模块"><strong>模块</strong></h1>

<h2 id="全局模块"><strong>全局模块</strong></h2>

<p>默认情况下，当你开始在一个新的 TypeScript 文件中写下代码时，它处于全局命名空间中。如在 <code>foo.ts</code> 里的以下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>如果你在相同的项目里创建了一个新的文件 <code>bar.ts</code>，TypeScript 类型系统将会允许你使用变量 <code>foo</code>，就好像它在全局可用一样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span> <span class="err">// allowed</span></code></pre></td></tr></table>
</div>
</div>
<p>毋庸置疑，使用全局变量空间是危险的，因为它会与文件内的代码命名冲突。我们推荐使用下文中将要提到的文件模块。</p>

<h2 id="文件模块"><strong>文件模块</strong></h2>

<p>它也被称为外部模块。如果在你的 TypeScript 文件的根级别位置含有 <code>import</code> 或者 <code>export</code>，它会在这个文件中创建一个本地的作用域。因此，我们需要把上文 <code>foo.ts</code> 改成如下方式（注意 <code>export</code> 用法）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">export</span> <span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>在全局命名空间里，我们不再有 <code>foo</code>，这可以通过创建一个新文件 <code>bar.ts</code> 来证明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span> <span class="err">// ERROR: &#34;cannot find name &#39;foo&#39;&#34;</span></code></pre></td></tr></table>
</div>
</div>
<p>如果你想在 <code>bar.ts</code> 里使用来自 <code>foo.ts</code> 的内容，你必须显式导入它，更新 <code>bar.ts</code> 如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">import</span> <span class="p">{</span> <span class="nx">foo</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./foo&#39;</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span> <span class="err">// allow</span></code></pre></td></tr></table>
</div>
</div>
<p>在 <code>bar.ts</code> 文件里使用 <code>import</code>，不但允许你使用从其他文件导入的内容，而且它会将此文件 <code>bar.ts</code> 标记为一个模块，文件内定义的声明也不会污染全局命名空间。</p>

<h2 id="文件模块详情"><strong>文件模块详情</strong></h2>

<p>文件模块拥有强大的能力和可用性。在这里，我们来讨论它的能力以及一些用法。</p>

<h2 id="澄清-commonjs-amd-es-modules-others"><strong>澄清：commonjs, amd, es modules, others</strong></h2>

<p>首先，我们需要澄清这些模块系统的不一致性。我将会提供给你我当前的建议，以及消除一些顾虑。</p>

<p>你可以根据不同的 <code>module</code> 选项来把 TypeScript 编译成不同的 JavaScript 模块类型，这有一些你可以忽略的：</p>

<ul>
<li>AMD：不要使用它，它仅能在浏览器工作；</li>
<li>SystemJS：这是一个好的实验，已经被 ES 模块替代；</li>
<li>ES 模块：它并没有准备好。</li>
</ul>

<p>使用 <code>module: commonjs</code> 选项来替代这些模式，这会是一个好的主意。</p>

<p>怎么书写 TypeScript 模块，这也是一件让人困惑的事。在今天我们应该这么做：</p>

<ul>
<li><code>import foo = require('foo')</code> 例如： <code>import/require</code> 使用 ES 模块语法。</li>
</ul>

<p>这很酷，接下来，让我们看看 ES 模块语法。</p>

<p><strong>TIP</strong></p>

<p>使用 <code>module: commonjs</code> 选项以及使用 ES 模块语法导入导出其他模块。</p>

<h2 id="es-模块语法"><strong>ES 模块语法</strong></h2>

<ul>
<li>使用 <code>export</code> 关键字导出一个变量（或者类型）：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="c1">// foo.ts
</span><span class="c1"></span>    <span class="kr">export</span> <span class="kr">const</span> <span class="nx">someVar</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="kr">export</span> <span class="nx">type</span> <span class="nx">someType</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span>: <span class="kt">string</span><span class="p">;</span>
    <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li><code>export</code> 的写法除了上面这样，还有另外一种：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="c1">// foo.ts
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">someVar</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="nx">type</span> <span class="nx">someType</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">type</span>: <span class="kt">string</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kr">export</span> <span class="p">{</span> <span class="nx">someVar</span><span class="p">,</span> <span class="nx">someType</span> <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>你也可以重命名变量导出：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="c1">// foo.ts
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">someVar</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="kr">export</span> <span class="p">{</span> <span class="nx">someVar</span> <span class="kr">as</span> <span class="nx">aDifferentName</span> <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>使用 <code>import</code> 关键字导入一个变量或者是一个类型：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="c1">// bar.ts
</span><span class="c1"></span>    <span class="kr">import</span> <span class="p">{</span> <span class="nx">someVar</span><span class="p">,</span> <span class="nx">someType</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./foo&#39;</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>重命名导入变量或者类型：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="c1">// bar.ts
</span><span class="c1"></span>    <span class="kr">import</span> <span class="p">{</span> <span class="nx">someVar</span> <span class="kr">as</span> <span class="nx">aDifferentName</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./foo&#39;</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="c1">// bar.ts
</span><span class="c1"></span>    <span class="kr">import</span> <span class="o">*</span> <span class="kr">as</span> <span class="nx">foo</span> <span class="nx">from</span> <span class="s1">&#39;./foo&#39;</span><span class="p">;</span>
    <span class="err">// 你可以使用 `foo.someVar` 和 `foo.someType` 以及其他任何从 `foo` 导出的变量或者类型</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>仅导入模块：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">import</span> <span class="s1">&#39;core-js&#39;</span><span class="p">;</span> <span class="err">// 一个普通的 polyfill 库</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>从其他模块导入后整体导出：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">export</span> <span class="o">*</span> <span class="nx">from</span> <span class="s1">&#39;./foo&#39;</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>从其他模块导入后，部分导出：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">export</span> <span class="p">{</span> <span class="nx">someVar</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./foo&#39;</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>通过重命名，部分导出从另一个模块导入的项目：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">export</span> <span class="p">{</span> <span class="nx">someVar</span> <span class="kr">as</span> <span class="nx">aDifferentName</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./foo&#39;</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="默认导入-导出"><strong>默认导入／导出</strong></h2>

<p>我并不喜欢用默认导出，虽然有默认导出的语法：</p>

<ul>
<li>使用 <code>export default</code>

<ul>
<li>在一个变量之前（不需要使用 <code>let/const/var</code>）；</li>
<li>在一个函数之前；</li>
<li>在一个类之前。</li>
</ul></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="c1">// some var
</span><span class="c1"></span>    <span class="kr">export</span> <span class="k">default</span> <span class="p">(</span><span class="nx">someVar</span> <span class="o">=</span> <span class="mi">123</span><span class="p">);</span>
    <span class="c1">// some function
</span><span class="c1"></span>    <span class="kr">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">someFunction() {</span><span class="p">}</span>
    <span class="c1">// some class
</span><span class="c1"></span>    <span class="kr">export</span> <span class="k">default</span> <span class="kr">class</span> <span class="nx">someClass</span> <span class="p">{}</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>导入使用 <code>import someName from 'someModule'</code> 语法（你可以根据需要为导入命名）：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">import</span> <span class="nx">someLocalNameForThisFile</span> <span class="nx">from</span> <span class="s1">&#39;./foo&#39;</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="模块路径"><strong>模块路径</strong></h2>

<p><strong>TIP</strong></p>

<p>假设你使用 <code>moduleResolution: node</code> 选项。这个选项应该在你 TypeScript 配置文件里。如果你使用了 <code>module: commonjs</code> 选项， <code>moduleResolution: node</code> 将会默认开启。</p>

<p>这里存在两种不同截然不同的模块，它们是由导入语句中的不同的路径写法所引起的（例如：<code>import foo from 'THIS IS THE PATH SECTION'</code>）。</p>

<ul>
<li>相对模块路径（路径以 <code>.</code> 开头，例如：<code>./someFile</code> 或者 <code>../../someFolder/someFile</code> 等）；</li>
<li>其他动态查找模块（如：<code>core-js</code>，<code>typestyle</code>，<code>react</code> 或者甚至是 <code>react/core</code> 等）。</li>
</ul>

<p>它们的主要区别来自于系统如何解析模块。</p>

<p><strong>TIP</strong></p>

<p>我将会使用一个概念性术语，<code>place</code> &ndash; 将在提及查找模式后解释它。</p>

<h2 id="相对模块路径"><strong>相对模块路径</strong></h2>

<p>这很简单，仅仅是按照相对路径：</p>

<ul>
<li>如果文件 <code>bar.ts</code> 中含有 <code>import * as foo from './foo'</code>，<code>foo</code> 文件所存在的地方必须是相同文件夹下；</li>
<li>如果文件 <code>bar.ts</code> 中含有 <code>import * as foo from '../foo'</code>，<code>foo</code> 文件所存在的地方必须是上一级目录；</li>
<li>如果文件 <code>bar.ts</code> 中含有 <code>import * as foo from '../someFolder/foo'</code>，<code>foo</code> 文件所在的文件夹 <code>someFolder</code> 必须与 <code>bar.ts</code> 所在文件夹在相同的目录下。</li>
</ul>

<p>或者，你还可以想想其他相对路径导入的情景。😃</p>

<h2 id="动态查找"><strong>动态查找</strong></h2>

<p>当导入路径不是相对路径时，模块解析将会模仿 <strong><a href="https://nodejs.org/api/modules.html#modules_all_together">Node 模块解析策略</a></strong>，以下我将给出一个简单例子：</p>

<ul>
<li>当你使用 <code>import * as foo from 'foo'</code>，将会按如下顺序查找模块：

<ul>
<li><code>./node_modules/foo</code></li>
<li><code>../node_modules/foo</code></li>
<li><code>../../node_modules/foo</code></li>
<li>直到系统的根目录</li>
</ul></li>
<li>当你使用 <code>import * as foo from 'something/foo'</code>，将会按照如下顺序查找内容

<ul>
<li><code>./node_modules/something/foo</code></li>
<li><code>../node_modules/something/foo</code></li>
<li><code>../../node_modules/something/foo</code></li>
<li>直到系统的根目录</li>
</ul></li>
</ul>

<h2 id="什么是-place"><strong>什么是 <code>place</code></strong></h2>

<p>当我提及被检查的 <code>place</code> 时，我想表达的是在这个 <code>place</code>，TypeScript 将会检查以下内容（例如一个 <code>foo</code> 的位置）：</p>

<ul>
<li>如果这个 <code>place</code> 表示一个文件，如：<code>foo.ts</code>，欢呼！</li>
<li>否则，如果这个 <code>place</code> 是一个文件夹，并且存在一个文件 <code>foo/index.ts</code>，欢呼！</li>
<li>否则，如果这个 <code>place</code> 是一个文件夹，并且存在一个 <code>foo/package.json</code> 文件，在该文件中指定 <code>types</code> 的文件存在，那么就欢呼！</li>
<li>否则，如果这个 <code>place</code> 是一个文件夹，并且存在一个 <code>package.json</code> 文件，在该文件中指定 <code>main</code> 的文件存在，那么就欢呼！</li>
</ul>

<p>从文件类型上来说，我实际上是指 <code>.ts</code>， <code>.d.ts</code> 或者 <code>.js</code></p>

<p>就是这样，现在你已经是一个模块查找专家（这并不是一个小小的成功）。</p>

<h2 id="重写类型的动态查找"><strong>重写类型的动态查找</strong></h2>

<p>在你的项目里，你可以通过 <code>declare module 'somePath'</code> 来声明一个全局模块的方式，用来解决查找模块路径的问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="c1">// globals.d.ts
</span><span class="c1"></span>    <span class="kr">declare</span> <span class="nx">module</span> <span class="s1">&#39;foo&#39;</span> <span class="p">{</span> <span class="c1">// some variable declarations export var bar: number;
</span><span class="c1"></span>    <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>接着：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="c1">// anyOtherTsFileInYourProject.ts
</span><span class="c1"></span>    <span class="kr">import</span> <span class="o">*</span> <span class="kr">as</span> <span class="nx">foo</span> <span class="nx">from</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
    <span class="c1">// TypeScript 将假设（在没有做其他查找的情况下）
</span><span class="c1"></span>    <span class="err">// foo 是 { bar: number }</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="import-require-仅仅是导入类型"><strong><code>import/require</code> 仅仅是导入类型</strong></h2>

<p>以下导入语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">import</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span></code></pre></td></tr></table>
</div>
</div>
<p>它实际上只做了两件事：</p>

<ul>
<li>导入 foo 模块的所有类型信息；</li>
<li>确定 foo 模块运行时的依赖关系。</li>
</ul>

<p>你可以选择仅加载类型信息，而没有运行时的依赖关系。在继续之前，你可能需要重新阅读本书的 <strong><a href="https://jkchao.github.io/typescript-book-chinese/project/declarationspaces.html">声明空间部分</a></strong> 部分。</p>

<p>如果你没有把导入的名称当做变量声明空间来用，在编译成 JavaScript 时，导入的模块将会被完全移除。这有一些较好的例子，当你了解了它们之后，我们将会给出一些使用例子。</p>

<h2 id="例子-1"><strong>例子 1</strong></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">import</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span></code></pre></td></tr></table>
</div>
</div>
<p>将会编译成 JavaScript：</p>

<p>这是正确的，一个没有被使用的空文件。</p>

<h2 id="例子-2"><strong>例子 2</strong></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">import</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">bar</span>: <span class="kt">foo</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>将会被编译成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kd">let</span> <span class="nx">bar</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>这是因为 foo （或者其他任何属性如：<code>foo.bas</code>）没有被当做一个变量使用。</p>

<h2 id="例子-3"><strong>例子 3</strong></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">import</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
    <span class="kr">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>将会被编译成（假设是 commonjs）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
    <span class="kr">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>这是因为 <code>foo</code> 被当做变量使用了。</p>

<h2 id="使用例子-懒加载"><strong>使用例子：懒加载</strong></h2>

<p>类型推断需要提前完成，这意味着，如果你想在 <code>bar</code> 文件里，使用从其他文件 <code>foo</code> 导出的类型，你将不得不这么做：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">import</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">bar</span>: <span class="kt">foo.SomeType</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>然而，在某些情景下，你只想在需要时加载模块 <code>foo</code>，此时你需要仅在类型注解中使用导入的模块名称，而不是在变量中使用。在编译成 JavaScript 式，这些将会被移除。接着，你可以手动导入你需要的模块。</p>

<p>做为一个例子，考虑以下基于 <code>commonjs</code> 的代码，我们仅在一个函数内导入 <code>foo</code> 模块：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">import</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
    <span class="kr">export</span> <span class="kd">function</span> <span class="nx">loadFoo() {</span> <span class="c1">// 这是懒加载 foo，原始的加载仅仅用来做类型注解 const _foo: typeof foo = require(&#39;foo&#39;); // 现在，你可以使用 `_foo` 替代 `foo` 来做为一个变量使用
</span><span class="c1"></span>    <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>一个同样简单的 <code>amd</code> 模块（使用 requirejs）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">import</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
    <span class="kr">export</span> <span class="kd">function</span> <span class="nx">loadFoo() {</span> <span class="c1">// 这是懒加载 foo，原始的加载仅仅用来做类型注解 require([&#39;foo&#39;], (_foo: typeof foo) =&gt; { // 现在，你可以使用 `_foo` 替代 `foo` 来做为一个变量使用 });
</span><span class="c1"></span>    <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这些通常在以下情景使用：</p>

<ul>
<li>在 web app 里， 当你在特定路由上加载 JavaScript 时；</li>
<li>在 node 应用里，当你只想加载特定模块，用来加快启动速度时。</li>
</ul>

<h2 id="使用例子-打破循环依赖"><strong>使用例子：打破循环依赖</strong></h2>

<p>类似于懒加载的使用用例，某些模块加载器（commonjs/node 和 amd/requirejs）不能很好的处理循环依赖。在这种情况下，一方面我们使用延迟加载代码，并在另一方面预先加载模块时很实用的。</p>

<h2 id="使用例子-确保导入"><strong>使用例子：确保导入</strong></h2>

<p>当你加载一个模块，只是想引入其附加的作用（如：模块可能会注册一些像 <strong><a href="https://codemirror.net/doc/manual.html#addons">CodeMirror addons</a></strong>）时，然而，如果你仅仅是 <code>import/require</code> （导入）一些并没有与你的模块或者模块加载器有任何依赖的 JavaScript 代码，（如：webpack），经过 TypeScript 编译后，这些将会被完全忽视。在这种情况下，你可以使用一个 <code>ensureImport</code> 变量，来确保编译的 JavaScript 依赖与模块。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-typescript" data-lang="typescript">    <span class="kr">import</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./foo&#39;</span><span class="p">);</span>
    <span class="kr">import</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./bar&#39;</span><span class="p">);</span>
    <span class="kr">import</span> <span class="nx">bas</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./bas&#39;</span><span class="p">);</span>
    <span class="kr">const</span> <span class="nx">ensureImport</span>: <span class="kt">any</span> <span class="o">=</span> <span class="nx">foo</span> <span class="o">||</span> <span class="nx">bar</span> <span class="o">||</span> <span class="nx">bas</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="globals-d-ts"><strong>globals.d.ts</strong></h2>

<p>在上文中，当我们讨论文件模块时，比较了全局变量与文件模块，并且我们推荐使用基于文件的模块，而不是选择污染全局命名空间。</p>

<p>然而，如果你的团队里有 TypeScript 初学者，你可以提供他们一个 <code>globals.d.ts</code> 文件，用来将一些接口或者类型放入全局命名空间里，这些定义的接口和类型能在你的所有 TypeScript 代码里使用。</p>

<p><strong>TIP</strong></p>

<p>对于任何需要编译成 JavaScript 代码，我们强烈建议你放入文件模块里。</p>

<ul>
<li><code>globals.d.ts</code> 是一种扩充 <code>lib.d.ts</code> 很好的方式，如果你需要。</li>
<li>当你从 <code>TS</code> 迁移到 <code>JS</code> 时，定义 <code>declare module &quot;some-library-you-dont-care-to-get-defs-for&quot;</code> 能让你快速开始。</li>
</ul>

<blockquote>
<blockquote>
<blockquote>
<p>转自 <a href="https://jkchao.github.io/typescript-book-chinese/project/modules.html">https://jkchao.github.io/typescript-book-chinese/project/modules.html</a></p>
</blockquote>
</blockquote>
</blockquote>
    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/javascript/">javascript</a>
          <a href="/tags/typescript/">typescript</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/flutter%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BC%83%E5%9D%911%E4%B9%8B%E9%83%A8%E7%BD%B2/">
            <span class="next-text nav-default">Flutter从入门到弃坑1之部署</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:terryzh017@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://stackoverflow.com/users/10838177/terryzh" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://twitter.com/terryzhAizz" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/t496971418" class="iconfont icon-github" title="github"></a>
  <a href="http://www.aizz.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2018 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Terryzh</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
