<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>2019React细节讲解 - Terryzh</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Terryzh" /><meta name="description" content="为什么选择使用框架而不是原生? 框架的好处: 组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维" /><meta name="keywords" content="javascript" />






<meta name="generator" content="Hugo 0.54.0 with even 4.0.0" />


<link rel="canonical" href="http://www.elixir-zh.cn/post/2019react%E7%BB%86%E8%8A%82%E8%AE%B2%E8%A7%A3/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.65dce888.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="2019React细节讲解" />
<meta property="og:description" content="为什么选择使用框架而不是原生? 框架的好处: 组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.elixir-zh.cn/post/2019react%E7%BB%86%E8%8A%82%E8%AE%B2%E8%A7%A3/" />
<meta property="article:published_time" content="2019-08-23T10:08:21&#43;08:00"/>
<meta property="article:modified_time" content="2019-08-23T10:08:21&#43;08:00"/>

<meta itemprop="name" content="2019React细节讲解">
<meta itemprop="description" content="为什么选择使用框架而不是原生? 框架的好处: 组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维">


<meta itemprop="datePublished" content="2019-08-23T10:08:21&#43;08:00" />
<meta itemprop="dateModified" content="2019-08-23T10:08:21&#43;08:00" />
<meta itemprop="wordCount" content="8395">



<meta itemprop="keywords" content="javascript," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="2019React细节讲解"/>
<meta name="twitter:description" content="为什么选择使用框架而不是原生? 框架的好处: 组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Terryzh</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Terryzh</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">2019React细节讲解</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-08-23 </span>
        <div class="post-category">
            <a href="/categories/code/"> code </a>
            </div>
          <span class="more-meta"> 8395 words </span>
          <span class="more-meta"> 17 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#为什么选择使用框架而不是原生">为什么选择使用框架而不是原生?</a></li>
<li><a href="#虚拟dom的优劣如何">虚拟DOM的优劣如何?</a></li>
<li><a href="#虚拟dom实现原理">虚拟DOM实现原理?</a></li>
<li><a href="#react最新的生命周期是怎样的">React最新的生命周期是怎样的?</a></li>
<li><a href="#react的请求应该放在哪个生命周期中">React的请求应该放在哪个生命周期中?</a></li>
<li><a href="#setstate到底是异步还是同步">setState到底是异步还是同步?</a></li>
<li><a href="#react组件通信如何实现">React组件通信如何实现?</a></li>
<li><a href="#react有哪些优化性能是手段">React有哪些优化性能是手段?</a></li>
<li><a href="#react如何进行组件-逻辑复用">React如何进行组件/逻辑复用?</a></li>
<li><a href="#mixin-hoc-render-props-react-hooks的优劣如何">mixin、hoc、render props、react-hooks的优劣如何？</a></li>
<li><a href="#你是如何理解fiber的">你是如何理解fiber的?</a></li>
<li><a href="#你对-time-slice的理解">你对 Time Slice的理解?</a></li>
<li><a href="#redux的工作流程">redux的工作流程?</a></li>
<li><a href="#react-redux是如何工作的">react-redux是如何工作的?</a></li>
<li><a href="#redux与mobx的区别">redux与mobx的区别?</a></li>
<li><a href="#redux中如何进行异步操作">redux中如何进行异步操作?</a></li>
<li><a href="#redux异步中间件之间的优劣">redux异步中间件之间的优劣?</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="为什么选择使用框架而不是原生">为什么选择使用框架而不是原生?</h2>

<p>框架的好处:</p>

<ol>
<li>组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。</li>
<li>天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。</li>
<li>生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案。</li>
<li>开发效率: 现代前端框架都默认自动更新DOM,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题.</li>
</ol>

<h2 id="虚拟dom的优劣如何">虚拟DOM的优劣如何?</h2>

<p>优点:</p>

<ul>
<li>保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限</li>
<li>无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率</li>
<li>跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等</li>
</ul>

<p>缺点:</p>

<ul>
<li>无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化</li>
</ul>

<h2 id="虚拟dom实现原理">虚拟DOM实现原理?</h2>

<ul>
<li>虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象</li>
<li>状态变更时，记录新树和旧树的差异</li>
<li>最后把差异更新到真正的dom中</li>
</ul>

<blockquote>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fxiaomuzhu%2Ffront-end-interview%2Fblob%2Fmaster%2Fdocs%2Fguide%2FvirtualDom.md">虚拟DOM原理</a></p>
</blockquote>

<h2 id="react最新的生命周期是怎样的">React最新的生命周期是怎样的?</h2>

<p>React 16之后有三个生命周期被废弃(但并未删除)</p>

<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>componentWillUpdate</li>
</ul>

<p>官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们</p>

<p>目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段</p>

<p>挂载阶段:</p>

<ul>
<li>constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义方法绑定this</li>
<li>getDerivedStateFromProps: <code>static getDerivedStateFromProps(nextProps, prevState)</code>,这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用getDerivedStateFromProps</li>
<li>render: render函数是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容</li>
<li>componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在componentWillUnmount中取消订阅</li>
</ul>

<p>更新阶段:</p>

<ul>
<li>getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用</li>
<li>shouldComponentUpdate: <code>shouldComponentUpdate(nextProps, nextState)</code>,有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能</li>
<li>render: 更新阶段也会触发此生命周期</li>
<li>getSnapshotBeforeUpdate: <code>getSnapshotBeforeUpdate(prevProps, prevState)</code>,这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与componentDidUpdate搭配使用</li>
<li>componentDidUpdate: <code>componentDidUpdate(prevProps, prevState, snapshot)</code>,该方法在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态。</li>
</ul>

<p>卸载阶段:</p>

<ul>
<li>componentWillUnmount: 当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作</li>
</ul>

<p><img src="/img/2019react/1.png" alt="1" /></p>

<blockquote>
<p>一个查看react生命周期的<a href="https://link.juejin.im/?target=http%3A%2F%2Fprojects.wojtekmaj.pl%2Freact-lifecycle-methods-diagram%2F">网站</a></p>
</blockquote>

<h2 id="react的请求应该放在哪个生命周期中">React的请求应该放在哪个生命周期中?</h2>

<p>React的异步请求到底应该放在哪个生命周期里,有人认为在<code>componentWillMount</code>中可以提前进行异步请求,避免白屏,其实这个观点是有问题的.</p>

<p>由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 - React继续前进并继续render,没有办法“暂停”渲染以等待数据到达。</p>

<p>而且在<code>componentWillMount</code>请求会有一系列潜在的问题,首先,在服务器渲染时,如果在 componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造成了多余的请求,其次,在React 16进行React Fiber重写后,<code>componentWillMount</code>可能在一次渲染中多次调用.</p>

<p>目前官方推荐的异步请求是在<code>componentDidmount</code>中进行.</p>

<p>如果有特殊需求需要提前请求,也可以在特殊情况下在<code>constructor</code>中请求:</p>

<blockquote>
<p>react 17之后<code>componentWillMount</code>会被废弃,仅仅保留<code>UNSAFE_componentWillMount</code></p>
</blockquote>

<h2 id="setstate到底是异步还是同步">setState到底是异步还是同步?</h2>

<p>先给出答案: 有时表现出异步,有时表现出同步</p>

<ol>
<li><strong>setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout 中都是同步的。</strong></li>
<li><strong>setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</strong></li>
<li><strong>setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。</strong></li>
</ol>

<h2 id="react组件通信如何实现">React组件通信如何实现?</h2>

<p>React组件间通信方式:</p>

<ul>
<li>父组件向子组件通讯: 父组件可以向子组件通过传 props 的方式，向子组件进行通讯</li>
<li>子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中</li>
<li>兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信</li>
<li>跨层级通信: <code>Context</code>设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过<code>Context</code>通信再适合不过</li>
<li>发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入event模块进行通信</li>
<li>全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维护一个全局状态中心Store,并根据不同的事件产生新的状态</li>
</ul>

<p><img src="/img/2019react/2.png" alt="2" /></p>

<h2 id="react有哪些优化性能是手段">React有哪些优化性能是手段?</h2>

<p>性能优化的手段很多时候是通用的详情见<a href="https://link.juejin.im/?target=%5Bload.md%5D(https%3A%2F%2Fgithub.com%2Fxiaomuzhu%2Ffront-end-interview%2Fblob%2Fmaster%2Fdocs%2Fguide%2Fload.md)">前端性能优化加载篇</a></p>

<h2 id="react如何进行组件-逻辑复用">React如何进行组件/逻辑复用?</h2>

<p>抛开已经被官方弃用的Mixin,组件抽象的技术目前有三种比较主流:</p>

<ul>
<li>高阶组件:

<ul>
<li>属性代理</li>
<li>反向继承</li>
</ul></li>
<li>渲染属性</li>
<li>react-hooks</li>
</ul>

<p>组件复用详解见<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fxiaomuzhu%2Ffront-end-interview%2Fblob%2Fmaster%2Fdocs%2Fguide%2Fabstract.md">组件复用</a></p>

<h2 id="mixin-hoc-render-props-react-hooks的优劣如何">mixin、hoc、render props、react-hooks的优劣如何？</h2>

<p>Mixin的缺陷：</p>

<ul>
<li>组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖组件的特定方法，但在定义组件时并不知道这种依赖关系）</li>
<li>多个 Mixin 之间可能产生冲突（比如定义了相同的state字段）</li>
<li>Mixin 倾向于增加更多状态，这降低了应用的可预测性（The more state in your application, the harder it is to reason about it.），导致复杂度剧增</li>
<li>隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：

<ul>
<li>难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互影响</li>
<li>组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它</li>
<li>Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个 Mixin 的输入输出</li>
</ul></li>
</ul>

<p><strong>HOC相比Mixin的优势:</strong></p>

<ul>
<li>HOC通过外层组件通过 Props 影响内层组件的状态，而不是直接改变其 State不存在冲突和互相干扰,这就降低了耦合度</li>
<li>不同于 Mixin 的打平+合并，HOC 具有天然的层级结构（组件树结构），这又降低了复杂度</li>
</ul>

<p><strong>HOC的缺陷:</strong></p>

<ul>
<li>扩展性限制: HOC 无法从外部访问子组件的 State因此无法通过shouldComponentUpdate滤掉不必要的更新,React 在支持 ES6 Class 之后提供了React.PureComponent来解决这个问题</li>
<li>Ref 传递问题: Ref 被隔断,后来的React.forwardRef 来解决这个问题</li>
<li>Wrapper Hell: HOC可能出现多层包裹组件的情况,多层抽象同样增加了复杂度和理解成本</li>
<li>命名冲突: 如果高阶组件多次嵌套,没有使用命名空间的话会产生冲突,然后覆盖老属性</li>
<li>不可见性: HOC相当于在原有组件外层再包装一个组件,你压根不知道外层的包装是啥,对于你是黑盒</li>
</ul>

<p><strong>Render Props优点:</strong></p>

<ul>
<li>上述HOC的缺点Render Props都可以解决</li>
</ul>

<p><strong>Render Props缺陷:</strong></p>

<ul>
<li>使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无法做到如此简单</li>
<li>嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套</li>
</ul>

<p><strong>React Hooks优点:</strong></p>

<ul>
<li>简洁: React Hooks解决了HOC和Render Props的嵌套问题,更加简洁</li>
<li>解耦: React Hooks可以更方便地把 UI 和状态分离,做到更彻底的解耦</li>
<li>组合: Hooks 中可以引用另外的 Hooks形成新的Hooks,组合变化万千</li>
<li>函数友好: React Hooks为函数组件而生,从而解决了类组件的几大问题:

<ul>
<li>this 指向容易错误</li>
<li>分割在不同声明周期中的逻辑使得代码难以理解和维护</li>
<li>代码复用成本高（高阶组件容易使代码量剧增）</li>
</ul></li>
</ul>

<p><strong>React Hooks缺陷:</strong></p>

<ul>
<li>额外的学习成本（Functional Component 与 Class Component 之间的困惑）</li>
<li>写法上有限制（不能出现在条件、循环中），并且写法限制增加了重构成本</li>
<li>破坏了PureComponent、React.memo浅比较的性能优化效果（为了取最新的props和state，每次render()都要重新创建事件处函数）</li>
<li>在闭包场景可能会引用到旧的state、props值</li>
<li>内部实现上不直观（依赖一份可变的全局状态，不再那么“纯”）</li>
<li>React.memo并不能完全替代shouldComponentUpdate（因为拿不到 state change，只针对 props change）</li>
</ul>

<blockquote>
<p>关于react-hooks的评价来源于官方<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Freactjs%2Frfcs%2Fblob%2Fmaster%2Ftext%2F0068-react-hooks.md%23drawbacks">react-hooks RFC</a></p>
</blockquote>

<h2 id="你是如何理解fiber的">你是如何理解fiber的?</h2>

<p>React Fiber 是一种基于浏览器的<strong>单线程调度算法</strong>.</p>

<p>React 16之前 ，<code>reconcilation</code> 算法实际上是递归，想要中断递归是很困难的，React 16 开始使用了循环来代替之前的递归.</p>

<p><code>Fiber</code>：<strong>一种将 recocilation（递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。</strong></p>

<blockquote>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fxiaomuzhu%2Ffront-end-interview%2Fblob%2Fmaster%2Fdocs%2Fguide%2Ffiber.md">Fiber 详解</a></p>
</blockquote>

<h2 id="你对-time-slice的理解">你对 Time Slice的理解?</h2>

<p><strong>时间分片</strong></p>

<ul>
<li>React 在渲染（render）的时候，不会阻塞现在的线程</li>
<li>如果你的设备足够快，你会感觉渲染是同步的</li>
<li>如果你设备非常慢，你会感觉还算是灵敏的</li>
<li>虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来</li>
<li>同样书写组件的方式</li>
</ul>

<p>也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果呢？</p>

<p><img src="/img/2019react/3.png" alt="3" /></p>

<p><img src="/img/2019react/4.png" alt="4" /></p>

<p>有图表三个图表，有一个输入框，以及上面的三种模式
每次<strong>输入东西的时候，就会进去一直在渲染。</strong>为了更好的看到渲染的性能，Dan为我们做了一个表。</p>

<p>我们先看看，同步模式：</p>

<p><img src="/img/2019react/5.png" alt="5" /></p>

<p><img src="/img/2019react/6.png" alt="6" /></p>

<p>同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！</p>

<p>我们再来看看第二种（Debounced模式）：</p>

<p><img src="/img/2019react/7.png" alt="7" /></p>

<p><img src="/img/2019react/8.png" alt="8" /></p>

<p>Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变化。这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。</p>

<p>切换到异步模式：</p>

<p><img src="/img/2019react/9.png" alt="9" /></p>

<p><img src="/img/2019react/10.png" alt="10" /></p>

<p>异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色的。</p>

<p>时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保证页面的流畅运行.</p>

<h2 id="redux的工作流程">redux的工作流程?</h2>

<p>首先，我们看下几个核心概念：</p>

<ul>
<li>Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。</li>
<li>State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这种时点的数据集合，就叫做State。</li>
<li>Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应该要发生变化了。</li>
<li>Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，所以我们定义一个函数来生成Action，这个函数就叫Action Creator。</li>
<li>Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参数，返回一个新的State。</li>
<li>dispatch：是View发出Action的唯一方法。</li>
</ul>

<p>然后我们过下整个工作流程：</p>

<ol>
<li>首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。</li>
<li>然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State</li>
<li>State一旦有变化，Store就会调用监听函数，来更新View。</li>
</ol>

<p>到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式保证了流程的清晰。</p>

<p><img src="/img/2019react/11.png" alt="11" /></p>

<blockquote>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fxiaomuzhu%2Ffront-end-interview%2Fblob%2Fmaster%2Fdocs%2Fguide%2Fredux.md">redux原理详解</a></p>
</blockquote>

<h2 id="react-redux是如何工作的">react-redux是如何工作的?</h2>

<ul>
<li>Provider: Provider的作用是从最外部封装了整个应用，并向connect模块传递store</li>
<li>connect: 负责连接React和Redux

<ul>
<li>获取state: connect通过context获取Provider中的store，通过store.getState()获取整个store tree 上所有state</li>
<li>包装原组件: 将state和action通过props的方式传入到原组件内部wrapWithConnect返回一个ReactComponent对象Connect，Connect重新render外部传入的原组件WrappedComponent，并把connect中传入的mapStateToProps, mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给WrappedComponent</li>
<li>监听store tree变化: connect缓存了store tree中state的状态,通过当前state状态和变更前state状态进行比较,从而确定是否调用<code>this.setState()</code>方法触发Connect及其子组件的重新渲染</li>
</ul></li>
</ul>

<p><img src="/img/2019react/12.png" alt="12" /></p>

<h2 id="redux与mobx的区别">redux与mobx的区别?</h2>

<p><strong>两者对比:</strong></p>

<ul>
<li>redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中</li>
<li>redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存数据，数据变化后自动处理响应的操作</li>
<li>redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改</li>
<li>mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用</li>
<li>mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易</li>
</ul>

<p><strong>场景辨析:</strong></p>

<p>基于以上区别,我们可以简单得分析一下两者的不同使用场景.</p>

<p>mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力不从心.</p>

<p>redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操作，由于redux不可变的特性，天然支持这些操作.</p>

<p>mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.</p>

<p>当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用mobx作为组件局部状态管理器来用.</p>

<h2 id="redux中如何进行异步操作">redux中如何进行异步操作?</h2>

<p>当然,我们可以在<code>componentDidmount</code>中直接进行请求无须借助redux.</p>

<p>但是在一定规模的项目中,上述方法很难进行异步流的管理,通常情况下我们会借助redux的异步中间件进行异步处理.</p>

<p>redux异步流中间件其实有很多,但是当下主流的异步中间件只有两种redux-thunk、redux-saga，当然redux-observable可能也有资格占据一席之地,其余的异步中间件不管是社区活跃度还是npm下载量都比较差了.</p>

<h2 id="redux异步中间件之间的优劣">redux异步中间件之间的优劣?</h2>

<p><strong>redux-thunk优点:</strong></p>

<ul>
<li>体积小: redux-thunk的实现方式很简单,只有不到20行代码</li>
<li>使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简单</li>
</ul>

<p><strong>redux-thunk缺陷:</strong></p>

<ul>
<li>样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的</li>
<li>耦合严重: 异步操作与redux的action偶合在一起,不方便管理</li>
<li>功能孱弱: 有一些实际开发中常用的功能需要自己进行封装</li>
</ul>

<p><strong>redux-saga优点:</strong></p>

<ul>
<li>异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中</li>
<li>action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满 “黑魔法” thunk function</li>
<li>异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理</li>
<li>功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者无须封装或者简单封装即可使用</li>
<li>灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow</li>
<li>易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等</li>
</ul>

<p><strong>redux-saga缺陷:</strong></p>

<ul>
<li>额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想</li>
<li>体积庞大: 体积略大,代码近2000行，min版25KB左右</li>
<li>功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码</li>
<li>ts支持不友好: yield无法返回TS类型</li>
</ul>

<p><strong>redux-observable优点:</strong></p>

<ul>
<li>功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你能想到的异步处理</li>
<li>背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而且随着rxjs的升级redux-observable也会变得更强大</li>
</ul>

<p><strong>redux-observable缺陷:</strong></p>

<ul>
<li>学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库</li>
<li>社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步流中间件这个层面redux-saga仍处于领导地位</li>
</ul>

<blockquote>
<p>关于redux-saga与redux-observable的详细比较可见<a href="https://link.juejin.im/?target=https%3A%2F%2Fhackmd.io%2F%402qVnJRlJRHCk20dvVxsySA%2FH1xLHUQ8e%3Ftype%3Dview%23side-by-side-**comparison**">此链接</a></p>

<p>作者：寻找海蓝96</p>

<p><a href="https://juejin.im/post/5d5f44dae51d4561df7805b4">链接</a></p>

<p>来源：掘金著作权归作者所有。</p>
</blockquote>
    </div>

    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/reward/wechat-qr-code.png">
        <span>wechat</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/reward/alipay-qr-code.png">
        <span>alipay</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/javascript/">javascript</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/flutter%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E4%B9%8Bios-native/">
            <span class="next-text nav-default">Flutter混合开发之IOS Native</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '2019-08-23 10:08:21 \x2b0800 \x2b0800',
        title: '2019React细节讲解',
        clientID: 'bf0ed9ea18e819e40135',
        clientSecret: '92bdc65717aa7f0ec48bfe94e773b57a21163785',
        repo: 'blog_comments',
        owner: '496971418@qq.com',
        admin: ['496971418@qq.com'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:terryzh017@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://stackoverflow.com/users/10838177/terryzh" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://twitter.com/terryzhAizz" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/t496971418" class="iconfont icon-github" title="github"></a>
  <a href="http://www.elixir-zh.cn/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2018 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Terryzh</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
